import abc
from abc import ABC
from codegen.skeleton.skeleton_tree import SkeletonTree
from codegen.skeleton.tree_node import SkeletonNodeVisitor
from codegen.skeleton.tree_node import SkeletonTreeNode
from codegen.skeleton.tree_node import SolutionNodeBase
from typing import List, Dict, Set, Optional
import sympy as sp


class IkSolutionGeneratorPythonBase(SkeletonNodeVisitor, ABC):
    """
    Assuming the parameters and ik_target_symbols have been expanded.
    This visitor generates the code that solve the IK problem.
    Usually, this code generated by this visitor will be used in a
    function. Thus, they shared the same indent.
    self.append_init_lines will be called before the visit, and
    self.append_finalize_lines will be called after the visit.
    """
    def __init__(self, tree: SkeletonTree, use_safe_operation: bool):
        super().__init__()
        self._n_nodes = tree.num_nodes
        self._tree = tree
        self._use_safe_operation = use_safe_operation

        # From symbol to variable index
        self._symbol_to_index: Dict[sp.Symbol, int] = dict()
        self._index_to_symbol: Dict[int, sp.Symbol] = dict()
        self._all_variables_in_tree = tree.all_solved_symbol()

        # Build the map
        all_solved_symbol_name_list = [symbol_i.name for symbol_i in self._all_variables_in_tree]
        all_solved_symbol_name_list = sorted(all_solved_symbol_name_list)
        for i in range(len(all_solved_symbol_name_list)):
            self._index_to_symbol[i] = sp.Symbol(all_solved_symbol_name_list[i])
            self._symbol_to_index[sp.Symbol(all_solved_symbol_name_list[i])] = i

        # The code
        # Should all be 1-indent, thus all ignored
        self._code_lines: List[str] = list()

    def add_code_line(self, code_line: str):
        self._code_lines.append(code_line)

    @abc.abstractmethod
    def append_init_lines(self):
        raise NotImplementedError

    @abc.abstractmethod
    def append_finalize_lines(self):
        raise NotImplementedError

    @property
    def generated_code_lines(self):
        return self._code_lines

    @property
    def symbol_to_index(self):
        return self._symbol_to_index

    # Common utility
    def generate_py_code(self, expr_to_proc: sp.Expr):
        if not self._use_safe_operation:
            return sp.pycode(expr_to_proc)

        # The function should be replaced
        function_replacements = {
            'math.sqrt': 'safe_sqrt',
            'math.asin': 'safe_asin',
            'math.acos': 'safe_acos'
        }

        # Do replacements
        original_code = sp.pycode(expr_to_proc)
        processed_code = original_code
        for func in function_replacements:
            replaced = function_replacements[func]
            processed_code = processed_code.replace(func, replaced)
        return processed_code

    @staticmethod
    def node_processor_name(node: SkeletonTreeNode):
        type_name = type(node).__name__
        if node.is_dispatcher_node:
            return '{type_name}_node_{idx}_processor'.format(idx=node.flatten_idx, type_name=type_name)
        # Solution node, also indicate the solved variable
        solution_node: SolutionNodeBase = node
        solved_var_name: str = solution_node.solution.solved_variable.name
        return '{type_name}_node_{idx}_solve_{var_name}_processor'.format(idx=node.flatten_idx, type_name=type_name,
                                                                          var_name=solved_var_name)

    def _verify_requested_variables_solved(
            self,
            requested_symbol_names: List[str],
            node: SkeletonTreeNode) -> bool:
        solutions_from_root = self._tree.variable_solutions_from_root(node, include_current_node=False)
        for symbol_i_name in requested_symbol_names:
            found = False
            for j in range(len(solutions_from_root)):
                solution_j = solutions_from_root[j]
                if solution_j.solved_variable.name == symbol_i_name:
                    found = True
                    break
            if not found:
                return False
        return True

    def gather_request_solved_variables(
            self,
            expressions_in:
            List[sp.Expr], node: SkeletonTreeNode) -> List[sp.Symbol]:
        # First get the requested symbols
        requested_symbol_names_set: Set[str] = set()
        for expr_i in expressions_in:
            for symbol_j in expr_i.free_symbols:
                if symbol_j in self._all_variables_in_tree:
                    requested_symbol_names_set.add(symbol_j.name)

        # Sort the name
        requested_symbol_names = [elem for elem in requested_symbol_names_set]
        requested_symbol_names = sorted(requested_symbol_names)

        # Next check they are in parent
        self._verify_requested_variables_solved(requested_symbol_names, node)

        # OK
        return [sp.Symbol(symbol_name) for symbol_name in requested_symbol_names]

    def get_requested_solved_variables(
            self,
            solution_i: Optional[sp.Expr],
            checker_i: Optional[sp.Expr],
            node: SkeletonTreeNode) -> List[sp.Symbol]:
        """
        For a given solution, check all variables it requires are already solved, and return them
        """
        # First get the requested symbols
        requested_symbol_names_set: Set[str] = set()
        if solution_i is not None:
            for symbol_i in solution_i.free_symbols:
                if symbol_i in self._all_variables_in_tree:
                    requested_symbol_names_set.add(symbol_i.name)
        if checker_i is not None:
            for symbol_i in checker_i.free_symbols:
                if symbol_i in self._all_variables_in_tree:
                    requested_symbol_names_set.add(symbol_i.name)
        requested_symbol_names = [elem for elem in requested_symbol_names_set]
        requested_symbol_names = sorted(requested_symbol_names)

        # Next check they are in parent
        self._verify_requested_variables_solved(requested_symbol_names, node)

        # OK
        return [sp.Symbol(symbol_name) for symbol_name in requested_symbol_names]

    def extract_solved_variable_codes(
            self,
            requested_variables: List[sp.Symbol],
            solution_name: str = 'this_solution') -> List[str]:
        extraction_lines: List[str] = list()
        for var_i in requested_variables:
            var_i_index = self._symbol_to_index[var_i]
            this_line = '{var_name} = {sol_name}[{idx}]'. \
                format(var_name=str(var_i), sol_name=solution_name, idx=var_i_index)
            extraction_lines.append(this_line)
        return extraction_lines

    def free_symbols(self, include_unknown_as_parameter: bool = True) -> List[sp.Symbol]:
        """
        All symbols that must be provided by the caller
        except the ik target
        """
        return self._tree.get_free_symbols(include_unknown_as_parameter)
